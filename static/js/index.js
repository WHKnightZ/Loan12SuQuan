(()=>{"use strict";var e={131:(e,t,o)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.loadTextures=t.cornerSelections=void 0;const a=o(876),s=o(451),l=o(555),n=async()=>{await Promise.all(a.EXPLOSION_KEYS.map((e=>((e,t)=>{const o=new Image;return o.src=(0,l.getImageSrc)(`explosions/${t}`),new Promise((t=>o.onload=()=>{a.mapTileInfo[e].explosions=[];for(let s=0;s<4;s+=1){const l=Math.floor(o.width/4*a.SCALE_RATIO),n=Math.floor(o.height*a.SCALE_RATIO),i=document.createElement("canvas");i.width=l,i.height=n;const r=i.getContext("2d");r.imageSmoothingEnabled=!1,r.drawImage(o,o.width/4*s,0,Math.floor(o.width/4),o.height,0,0,l,n);const p=new Image;p.src=i.toDataURL("image/png"),p.onload=()=>{a.mapTileInfo[e].explosions[s]=p,t(null)}}}))})(a.TILES[e],e.toLowerCase())))),a.mapTileInfo[a.TILES.SWORDRED].explosions=a.mapTileInfo[a.TILES.SWORD].explosions};t.cornerSelections=[];const i=()=>{t.cornerSelections=[];let e=new Image;return e.src=(0,l.getImageSrc)("selection/corner"),new Promise((o=>{e.onload=async()=>{const l=await(0,s.flipHorizontal)(e),n=await(0,s.flipVertical)(e),i=await(0,s.flipVertical)(l),r=e.width,p=a.CELL_SIZE-r;t.cornerSelections.push({texture:e,position:{x:0,y:0},offset:{x:1,y:1}}),t.cornerSelections.push({texture:l,position:{x:p,y:0},offset:{x:-1,y:1}}),t.cornerSelections.push({texture:n,position:{x:0,y:p},offset:{x:1,y:-1}}),t.cornerSelections.push({texture:i,position:{x:p,y:p},offset:{x:-1,y:-1}}),o(null)}}))};t.loadTextures=()=>Promise.all([Promise.all((0,l.getKeys)(a.TILES).map((e=>((e,t)=>{const o=new Image;return o.src=(0,l.getImageSrc)(`tiles/${t}`),new Promise((t=>o.onload=()=>{const s=document.createElement("canvas");s.width=a.TILE_SIZE,s.height=a.TILE_SIZE;const l=s.getContext("2d");l.imageSmoothingEnabled=!1,l.drawImage(o,0,0,a.TILE_SIZE,a.TILE_SIZE);const n=new Image;n.src=s.toDataURL("image/png"),n.onload=()=>{a.mapTileInfo[e].texture=n,t(null)}}))})(a.TILES[e],e.toLowerCase())))),n(),i()])},876:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.cornerSelectionOffsets=t.base=t.EXPLOSION_KEYS=t.mapTileInfo=t.COUNT_TILES=t.TILES=t.CORNER_SELECTION_CYCLE=t.SCALE_RATIO=t.GRAVITY=t.VELOCITY_BASE=t.SWAP_OFFSET=t.SWAP_DURATION=t.MATCH_4_POINT=t.GAIN_TURN=t.TILE_OFFSET=t.TILE_SIZE=t.SCREEN_SIZE=t.CELL_SIZE=t.MAP_WIDTH_1=t.MAP_WIDTH=t.BOARD_COLORS=t.APP_NAME=void 0,t.APP_NAME="Loạn 12 Sứ Quân",t.BOARD_COLORS=["#3e3226","#554933"],t.MAP_WIDTH=8,t.MAP_WIDTH_1=t.MAP_WIDTH-1,t.CELL_SIZE=60,t.SCREEN_SIZE=t.MAP_WIDTH*t.CELL_SIZE,t.TILE_SIZE=54,t.TILE_OFFSET=Math.floor((t.CELL_SIZE-t.TILE_SIZE)/2),t.GAIN_TURN=3,t.MATCH_4_POINT=50,t.SWAP_DURATION=10,t.SWAP_OFFSET=t.CELL_SIZE/t.SWAP_DURATION,t.VELOCITY_BASE=2,t.GRAVITY=.4,t.SCALE_RATIO=t.TILE_SIZE/22,t.CORNER_SELECTION_CYCLE=30,t.TILES={SWORD:0,HEART:1,GOLD:2,ENERGY:3,MANA:4,EXP:5,SWORDRED:6},t.COUNT_TILES=Object.keys(t.TILES).length,t.mapTileInfo={[t.TILES.SWORD]:{compatible:[t.TILES.SWORDRED],probability:100,point:10,texture:null,explosions:[]},[t.TILES.HEART]:{compatible:[],probability:100,point:9,texture:null,explosions:[]},[t.TILES.GOLD]:{compatible:[],probability:100,point:6,texture:null,explosions:[]},[t.TILES.ENERGY]:{compatible:[],probability:100,point:7,texture:null,explosions:[]},[t.TILES.MANA]:{compatible:[],probability:100,point:8,texture:null,explosions:[]},[t.TILES.EXP]:{compatible:[],probability:100,point:6,texture:null,explosions:[]},[t.TILES.SWORDRED]:{compatible:[t.TILES.SWORD],probability:10,point:30,texture:null,explosions:[]}},t.EXPLOSION_KEYS=["SWORD","HEART","GOLD","ENERGY","MANA","EXP"],t.base={},t.cornerSelectionOffsets=Array.from({length:t.CORNER_SELECTION_CYCLE}).map(((e,o)=>Math.floor(3*Math.sin(2*Math.PI*o/t.CORNER_SELECTION_CYCLE))))},367:(e,t,o)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Game=void 0;const a=o(131),s=o(876),l=o(555),n={IDLE:{render:()=>{},update:()=>{}},SELECT:{render:e=>{const t=e.tSwap*s.SWAP_OFFSET,{x:o,y:l,value:n}=e.selected,{x:i,y:r,value:p}=e.swapped||e.selected;if(e.swapped&&s.base.context.drawImage(s.mapTileInfo[p].texture,i*s.CELL_SIZE+s.TILE_OFFSET+(o-i)*t,r*s.CELL_SIZE+s.TILE_OFFSET+(l-r)*t),s.base.context.drawImage(s.mapTileInfo[n].texture,o*s.CELL_SIZE+s.TILE_OFFSET+(i-o)*t,l*s.CELL_SIZE+s.TILE_OFFSET+(r-l)*t),!e.swapped){const t=s.cornerSelectionOffsets[e.tSelect%s.CORNER_SELECTION_CYCLE];a.cornerSelections.forEach((({texture:o,offset:a,position:l})=>s.base.context.drawImage(o,e.selected.x*s.CELL_SIZE+l.x+a.x*t,e.selected.y*s.CELL_SIZE+l.y+a.y*t)))}},update:e=>{if(!e.swapped)return void(e.tSelect+=1);if(e.tSwap+=1,e.tSwap<=s.SWAP_DURATION)return;e.tSwap=s.SWAP_DURATION;const{x:t,y:o,value:a}=e.selected,{x:n,y:i,value:r}=e.swapped;if(s.base.map[o][t]=a,s.base.map[i][n]=r,e.swap(t,o,n,i),e.reswap)e.reswap=!1,e.selected=e.swapped=null,e.state="IDLE";else{const{matched:a,tiles:r}=e.matchPosition(t,o),{matched:p,tiles:E}=e.matchPosition(n,i);if(a||p)e.selected=e.swapped=null,e.explodedTiles=(0,l.combine)([r,E]),e.explosions=[],e.explodedTiles.forEach((({x:t,y:o})=>{e.explosions.push({x:t,y:o,value:s.base.map[o][t]}),s.base.map[o][t]=-1})),e.state="EXPLODE";else{s.base.map[o][t]=-1,s.base.map[i][n]=-1;const a=e.selected.x,l=e.selected.y;e.selected.x=e.swapped.x,e.selected.y=e.swapped.y,e.swapped.x=a,e.swapped.y=l,e.reswap=!0,e.tSwap=0}}}},EXPLODE:{render:e=>{e.explosions.forEach((({x:t,y:o,value:a})=>{const l=s.mapTileInfo[a].explosions[e.tExplode];s.base.context.drawImage(l,t*s.CELL_SIZE+Math.floor((s.CELL_SIZE-l.width)/2),o*s.CELL_SIZE+Math.floor((s.CELL_SIZE-l.height)/2))}))},update:e=>{e.tExplode2+=1,e.tExplode2%2==0&&(e.tExplode+=1,4===e.tExplode&&(e.tExplode=0,e.state="FALL",e.fall={},e.explodedTiles.forEach((({x:t,y:o})=>{s.base.map[o][t]=-1,e.fall[t]?!e.fall[t].list.find((({x:e,y:a})=>e===t&&a===o))&&e.fall[t].list.push({x:t,y:o,v:0,offset:0,value:-1}):e.fall[t]={list:[{x:t,y:o,v:0,offset:0,value:-1}],below:-1}})),(0,l.getKeys)(e.fall).forEach((t=>{e.fall[t].below=(0,l.findBelow)(e.fall[t].list);const o=e.fall[t].list.length;e.fall[t].list=[],t=Number(t);for(let o=e.fall[t].below;o>=0;o-=1)-1!==s.base.map[o][t]&&(e.fall[t].list.push({x:t,y:o,v:s.VELOCITY_BASE,offset:0,value:s.base.map[o][t]}),s.base.map[o][t]=-1);for(let a=0;a<o;a+=1)e.fall[t].list.push({x:t,y:-1-a,v:s.VELOCITY_BASE,offset:0,value:(0,l.randomTile)()})}))))}},FALL:{render:e=>{(0,l.getKeys)(e.fall).forEach((t=>{e.fall[t].list.forEach((({x:e,y:t,value:o,offset:a})=>{s.base.context.drawImage(s.mapTileInfo[o].texture,e*s.CELL_SIZE+s.TILE_OFFSET,t*s.CELL_SIZE+s.TILE_OFFSET+a)}))}))},update:e=>{let t=!1;if((0,l.getKeys)(e.fall).forEach((o=>{const a=e.fall[o];o=Number(o);let l=!1;a.list.forEach(((e,t)=>{e.v+=s.GRAVITY,e.offset+=e.v;const n=e.y+Math.floor((e.offset+6)/s.CELL_SIZE);0===t?n>=a.below&&(l=!0,s.base.map[a.below][o]=e.value,a.below-=1):(e.offset>=a.list[t-1].offset-6||n>=a.below-t+1)&&(e.v=s.VELOCITY_BASE,e.offset=Math.floor(e.offset/s.CELL_SIZE)*s.CELL_SIZE)})),l&&a.list.shift(),a.list.length&&(t=!0)})),t)return;const o=[];for(let t=0;t<s.MAP_WIDTH;t+=1)for(let a=0;a<s.MAP_WIDTH;a+=1){const{matched:s,tiles:l}=e.matchPosition(a,t);s&&o.push(l)}o.length?(e.explodedTiles=(0,l.combine)(o),e.explosions=[],e.explodedTiles.forEach((({x:t,y:o})=>{e.explosions.push({x:t,y:o,value:s.base.map[o][t]}),s.base.map[o][t]=-1})),e.state="EXPLODE"):e.state="IDLE"}}};t.Game=class{state;selected;swapped;reswap;fall;explosions;explodedTiles;tSelect;tSwap;tExplode;tExplode2;constructor(){}init(){s.base.map=(0,l.generateMap)(),this.state="IDLE",this.selected=null,this.swapped=null,this.reswap=!1,this.fall={},this.explosions=[],this.tSelect=0,this.tSwap=0,this.tExplode=0,this.tExplode2=0}matchPosition(e,t){let o,a,n=[],i=[];const r=s.base.map[t][e],p=s.mapTileInfo[r].compatible;for(o=e-1;o>=0;){const e=s.base.map[t][o];if(!(0,l.check)(e,r,p))break;n.push({x:o,y:t,point:s.mapTileInfo[e].point,value:e}),o-=1}for(o=e+1;o<s.MAP_WIDTH;){const e=s.base.map[t][o];if(!(0,l.check)(e,r,p))break;n.push({x:o,y:t,point:s.mapTileInfo[e].point,value:e}),o+=1}for(a=t-1;a>=0;){const t=s.base.map[a][e];if(!(0,l.check)(t,r,p))break;i.push({x:e,y:a,point:s.mapTileInfo[t].point,value:t}),a-=1}for(a=t+1;a<s.MAP_WIDTH;){const t=s.base.map[a][e];if(!(0,l.check)(t,r,p))break;i.push({x:e,y:a,point:s.mapTileInfo[t].point,value:t}),a+=1}let E=!0,c=!0;n.length<2&&(n=[],E=!1),i.length<2&&(i=[],c=!1);const I=E||c,d=s.base.map[t][e],f=I?[...n,...i,{x:e,y:t,point:s.mapTileInfo[d].point,value:d}]:[];return{matched:I,tiles:f,point:f.reduce(((e,t)=>e+t.point),0)+(n.length>=s.GAIN_TURN?s.MATCH_4_POINT:0)+(i.length>=s.GAIN_TURN?s.MATCH_4_POINT:0),turn:Number(n.length>=s.GAIN_TURN)+Number(i.length>=s.GAIN_TURN)}}swap(e,t,o,a){const l=s.base.map[t][e];s.base.map[t][e]=s.base.map[a][o],s.base.map[a][o]=l}addMatchedPosition(e,t,o,a,s){this.swap(t,o,a,s);const{matched:l,point:n}=this.matchPosition(t,o),{matched:i,point:r}=this.matchPosition(a,s);(l||i)&&e.push({x0:t,y0:o,x1:a,y1:s,point:n+r}),this.swap(t,o,a,s)}findAllMatchedPositions(){const e=[];for(let t=0;t<s.MAP_WIDTH_1;t+=1)for(let o=0;o<s.MAP_WIDTH_1;o+=1)this.addMatchedPosition(e,o,t,o+1,t),this.addMatchedPosition(e,o,t,o,t+1);for(let t=0;t<s.MAP_WIDTH_1;t+=1)this.addMatchedPosition(e,s.MAP_WIDTH_1,t,s.MAP_WIDTH_1,t+1);for(let t=0;t<s.MAP_WIDTH_1;t+=1)this.addMatchedPosition(e,t,s.MAP_WIDTH_1,t+1,s.MAP_WIDTH_1);return e.sort(((e,t)=>e.point<t.point?1:-1)),e}onClick(e){if("IDLE"!==this.state&&"SELECT"!==this.state)return;const t=s.base.canvas,o=Math.floor(e.offsetX*t.width/t.clientWidth/s.CELL_SIZE),a=Math.floor(e.offsetY*t.height/t.clientHeight/s.CELL_SIZE);if(!(o<0||o>=s.MAP_WIDTH||a<0||a>=s.MAP_WIDTH)){if(this.tSwap=0,!this.selected)return this.selected={x:o,y:a,value:s.base.map[a][o]},s.base.map[a][o]=-1,void(this.state="SELECT");if(Math.abs(o-this.selected.x)+Math.abs(a-this.selected.y)!==1){const{x:e,y:t,value:o}=this.selected;return s.base.map[t][e]=o,this.selected=null,void(this.state="IDLE")}this.swapped={x:o,y:a,value:s.base.map[a][o]},s.base.map[a][o]=-1}}render(){for(let e=0;e<s.MAP_WIDTH;e+=1)for(let t=0;t<s.MAP_WIDTH;t+=1){s.base.context.fillStyle=s.BOARD_COLORS[(e+t)%2];const o=t*s.CELL_SIZE,a=e*s.CELL_SIZE;s.base.context.fillRect(o,a,s.CELL_SIZE,s.CELL_SIZE),-1!==s.base.map[e][t]&&s.base.context.drawImage(s.mapTileInfo[s.base.map[e][t]].texture,o+s.TILE_OFFSET,a+s.TILE_OFFSET)}n[this.state].render(this)}update(){n[this.state].update(this)}}},451:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.resize=t.flipVertical=t.flipHorizontal=void 0,t.flipHorizontal=e=>{const t=e.width,o=e.height,a=document.createElement("canvas");a.width=t,a.height=o;const s=a.getContext("2d");return s.translate(t,0),s.scale(-1,1),s.drawImage(e,0,0),(e=new Image).src=a.toDataURL("image/png"),new Promise((t=>e.onload=()=>t(e)))},t.flipVertical=e=>{const t=e.width,o=e.height,a=document.createElement("canvas");a.width=t,a.height=o;const s=a.getContext("2d");return s.translate(0,0),s.scale(1,-1),s.drawImage(e,0,-e.height),(e=new Image).src=a.toDataURL("image/png"),new Promise((t=>e.onload=()=>t(e)))},t.resize=(e,t=1)=>{const o=Math.floor(e.width*t),a=Math.floor(e.height*t),s=document.createElement("canvas");s.width=o,s.height=a;const l=s.getContext("2d");l.imageSmoothingEnabled=!1,l.drawImage(e,0,0,o,a);const n=new Image;return n.src=s.toDataURL("image/png"),new Promise((e=>{n.onload=()=>e(n)}))}},555:(e,t,o)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.combine=t.getKey=t.findBelow=t.check=t.generateMap=t.randomTile=t.random=t.getImageSrc=t.getKeys=t.getAppName=void 0;const a=o(876);t.getAppName=()=>a.APP_NAME,t.getKeys=Object.keys,t.getImageSrc=(e,t="png")=>`/static/images/${e}.${t}`,t.random=(e,t)=>Math.floor(Math.random()*(t-e))+e;let s=0;const l=Array.from({length:a.COUNT_TILES}).map(((e,t)=>{const o=a.mapTileInfo[t].probability;return s+=o,s}));t.randomTile=()=>{const e=(0,t.random)(0,s);for(let t=0;t<a.COUNT_TILES;t+=1)if(e<=l[t])return t;return-1},t.generateMap=()=>{const e=Array.from({length:a.MAP_WIDTH}).map((()=>Array.from({length:a.MAP_WIDTH}).map(t.randomTile))),o=(t,o,a,s)=>{const l=e[o][t];return l===a||s.includes(l)},s=(t,s)=>{let l=0,n=0;const i=e[s][t],r=a.mapTileInfo[i].compatible;let p=t+1;for(;p<a.MAP_WIDTH&&o(p,s,i,r);)l+=1,p+=1;if(l>=2)return!0;let E=s+1;for(;E<a.MAP_WIDTH&&o(t,E,i,r);)n+=1,E+=1;return n>=2};let l=!0;for(;l;){l=!1;for(let o=0;o<a.MAP_WIDTH;o+=1)for(let n=0;n<a.MAP_WIDTH;n+=1)s(n,o)&&(l=!0,e[o][n]=(0,t.randomTile)())}return e},t.check=(e,t,o)=>e===t||o.includes(e),t.findBelow=e=>e.reduce(((e,t)=>e<t.y?t.y:e),-1),t.getKey=(e,t)=>t*a.MAP_WIDTH+e,t.combine=e=>{const o=[],a={};return e.forEach((e=>{e.forEach((e=>{const{x:s,y:l,value:n}=e,i=(0,t.getKey)(s,l);a[i]||(a[i]=!0,o.push(e))}))})),o}}},t={};function o(a){var s=t[a];if(void 0!==s)return s.exports;var l=t[a]={exports:{}};return e[a](l,l.exports,o),l.exports}(()=>{const e=o(131),t=o(876),a=new(o(367).Game),s=(e=0)=>{requestAnimationFrame(s),a.update(),a.render()};(async()=>{(()=>{const e=document.getElementById("canvas"),o=e.getContext("2d");e.width=e.height=t.SCREEN_SIZE,o.imageSmoothingEnabled=!1,t.base.canvas=e,t.base.context=o})(),await(0,e.loadTextures)(),a.init(),document.addEventListener("click",(e=>{a.onClick(e)})),s()})()})()})();
//# sourceMappingURL=index.js.map